# 套接字有两种：
# 分别是基于文件型的和基于网络型的
# 也被称为进程间通讯也被称为ipc
  #  进程之间是没办法直接进行通信的
   # 基于文件中的套接字 可以实现 一台主机上多个应用程序之间的通信


    # 套接字家族的名字：AF_UNIX
    # unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，
    # 两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信

# 套接字家族的名字：AF_INET
#
# (还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，
# 他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，
# 或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，
# 但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)
# 服务端套接字函数
# s.bind()    绑定(主机,端口号)到套接字
# s.listen()  开始TCP监听
# s.accept()  被动接受TCP客户的连接,(阻塞式)等待连接的到来
#
# 客户端套接字函数
# s.connect()     主动初始化TCP服务器连接
# s.connect_ex()  connect()函数的扩展版本,出错时返回出错码,而不是抛出异常
#
# 公共用途的套接字函数
# s.recv()            接收TCP数据
# s.send()            发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)
# s.sendall()         发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)
# s.recvfrom()        接收UDP数据
# s.sendto()          发送UDP数据
# s.getpeername()     连接到当前套接字的远端的地址
# s.getsockname()     当前套接字的地址
# s.getsockopt()      返回指定套接字的参数
# s.setsockopt()      设置指定套接字的参数
# s.close()           关闭套接字
#
# 面向锁的套接字方法
# s.setblocking()     设置套接字的阻塞与非阻塞模式
# s.settimeout()      设置阻塞套接字操作的超时时间
# s.gettimeout()      得到阻塞套接字操作的超时时间
#
# 面向文件的套接字的函数
# s.fileno()          套接字的文件描述符
# s.makefile()        创建一个与该套接字相关的文件
# tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端
#
# tcp服务端
#
# 复制代码
# 1 ss = socket() #创建服务器套接字
# 2 ss.bind()      #把地址绑定到套接字
# 3 ss.listen()      #监听链接
# 4 inf_loop:      #服务器无限循环
# 5     cs = ss.accept() #接受客户端链接
# 6     comm_loop:         #通讯循环
# 7         cs.recv()/cs.send() #对话(接收与发送)
# 8     cs.close()    #关闭客户端套接字
# 9 ss.close()        #关闭服务器套接字(可选)
# 复制代码
# tcp客户端
#
# 1 cs = socket()    # 创建客户套接字
# 2 cs.connect()    # 尝试连接服务器
# 3 comm_loop:        # 通讯循环
# 4     cs.send()/cs.recv()    # 对话(发送/接收)
# 5 cs.close()            # 关闭客户套接字